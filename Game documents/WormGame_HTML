<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Worm - File Eating Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }
        
        body {
            background: linear-gradient(135deg, #0a192f 0%, #1a365d 100%);
            color: #e6f1ff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 800px;
        }
        
        h1 {
            color: #64ffda;
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
        }
        
        .subtitle {
            color: #8892b0;
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        
        .game-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .game-board {
            position: relative;
            background-color: #112240;
            border: 3px solid #233554;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            background-color: #0a192f;
        }
        
        .game-info {
            background-color: #112240;
            border: 3px solid #233554;
            border-radius: 10px;
            padding: 25px;
            width: 300px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .stats {
            margin-bottom: 25px;
        }
        
        .stat-box {
            background-color: #1a365d;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #64ffda;
        }
        
        .stat-box h3 {
            color: #64ffda;
            margin-bottom: 5px;
            font-size: 1.1rem;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #e6f1ff;
        }
        
        .power-ups {
            margin-bottom: 25px;
        }
        
        .power-ups h3 {
            color: #64ffda;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.3rem;
        }
        
        .power-up-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        
        .power-up-item {
            background-color: #1a365d;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .power-up-item.active {
            border-color: #64ffda;
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
        }
        
        .power-up-icon {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }
        
        .instructions {
            background-color: #1a365d;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .instructions h3 {
            color: #64ffda;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        .instructions ul {
            list-style-type: none;
            padding-left: 10px;
        }
        
        .instructions li {
            margin-bottom: 10px;
            padding-left: 25px;
            position: relative;
        }
        
        .instructions li:before {
            content: ">";
            color: #64ffda;
            position: absolute;
            left: 0;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        button {
            background-color: #233554;
            color: #e6f1ff;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s;
            border: 2px solid #64ffda;
        }
        
        button:hover {
            background-color: #64ffda;
            color: #0a192f;
            transform: translateY(-2px);
        }
        
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(17, 34, 64, 0.95);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            border: 3px solid #64ffda;
            display: none;
            z-index: 10;
            min-width: 300px;
        }
        
        .game-message h2 {
            color: #64ffda;
            margin-bottom: 20px;
            font-size: 2rem;
        }
        
        .game-message p {
            margin-bottom: 25px;
            font-size: 1.2rem;
        }
        
        .item-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .file-types {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .file-type {
            background-color: #1a365d;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            font-size: 0.9rem;
        }
        
        @media (max-width: 900px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            
            .game-info {
                width: 100%;
                max-width: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üñ•Ô∏è CYBER WORM üêõ</h1>
        <p class="subtitle">Eat files, avoid viruses, collect power-ups!</p>
    </div>
    
    <div class="game-container">
        <div class="game-board">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
            <div id="gameOverMessage" class="game-message">
                <h2>SYSTEM COMPROMISED!</h2>
                <p>Your worm has been detected!</p>
                <p id="finalScore">Score: 0</p>
                <button onclick="restartGame()">üîÑ RESTART WORM</button>
            </div>
            <div id="startMessage" class="game-message">
                <h2>CYBER WORM</h2>
                <p>Use arrow keys or WASD to move</p>
                <p>Eat files to grow and score points</p>
                <p>Avoid infected PCs and don't crash into yourself!</p>
                <button onclick="startGame()">üöÄ START INFECTION</button>
            </div>
        </div>
        
        <div class="game-info">
            <div class="stats">
                <div class="stat-box">
                    <h3>üìÅ FILES EATEN</h3>
                    <div id="score" class="stat-value">0</div>
                </div>
                <div class="stat-box">
                    <h3>üíæ WORM LENGTH</h3>
                    <div id="length" class="stat-value">3</div>
                </div>
                <div class="stat-box">
                    <h3>‚ù§Ô∏è SYSTEM HEALTH</h3>
                    <div id="health" class="stat-value">3</div>
                </div>
            </div>
            
            <div class="power-ups">
                <h3>‚ö° ACTIVE POWER-UPS</h3>
                <div class="power-up-grid">
                    <div id="speedPower" class="power-up-item">
                        <div class="power-up-icon">‚ö°</div>
                        <div>Speed Boost</div>
                        <div id="speedTimer">0s</div>
                    </div>
                    <div id="shieldPower" class="power-up-item">
                        <div class="power-up-icon">üõ°Ô∏è</div>
                        <div>Firewall</div>
                        <div id="shieldTimer">0s</div>
                    </div>
                    <div id="doublePower" class="power-up-item">
                        <div class="power-up-icon">2X</div>
                        <div>Double Points</div>
                        <div id="doubleTimer">0s</div>
                    </div>
                    <div id="antivirusPower" class="power-up-item">
                        <div class="power-up-icon">üíä</div>
                        <div>Antivirus</div>
                        <div id="antivirusTimer">0s</div>
                    </div>
                </div>
            </div>
            
            <div class="instructions">
                <h3>üéÆ HOW TO PLAY</h3>
                <ul>
                    <li><strong>Arrow Keys</strong> or <strong>WASD</strong> to move</li>
                    <li>Eat <span style="color:#4dabf7">üìÅ Files</span> to grow (+10 pts)</li>
                    <li>Avoid <span style="color:#ff6b6b">üñ•Ô∏è Infected PCs</span> (-1 health)</li>
                    <li>Collect power-ups for advantages</li>
                    <li>Don't hit yourself!</li>
                </ul>
                
                <div class="item-legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #40c057;"></div>
                        <span>Worm Head</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4dabf7;"></div>
                        <span>Files</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff6b6b;"></div>
                        <span>Infected PCs</span>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <button onclick="pauseGame()">‚è∏Ô∏è PAUSE</button>
                <button onclick="restartGame()">üîÑ RESTART</button>
            </div>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 20;
        const tileCount = canvas.width / gridSize;
        
        let worm = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let food = [];
        let obstacles = [];
        let powerUps = [];
        let gameSpeed = 10; // Frames per move
        let frameCount = 0;
        let score = 0;
        let health = 3;
        let gameRunning = false;
        let gamePaused = false;
        let gameOver = false;
        
        // Power-up timers
        let speedBoost = 0;
        let firewall = 0;
        let doublePoints = 0;
        let antivirus = 0;
        
        // File types with different values
        const fileTypes = [
            { emoji: 'üìÅ', color: '#4dabf7', value: 10, name: 'Document' },
            { emoji: 'üìä', color: '#20c997', value: 15, name: 'Spreadsheet' },
            { emoji: 'üé®', color: '#be4bdb', value: 12, name: 'Design File' },
            { emoji: 'üìπ', color: '#fd7e14', value: 20, name: 'Video File' },
            { emoji: 'üîí', color: '#ffd43b', value: 25, name: 'Encrypted File' }
        ];
        
        // Power-up types
        const powerUpTypes = [
            { emoji: '‚ö°', color: '#ffd43b', type: 'speed', duration: 300, name: 'Speed Boost' },
            { emoji: 'üõ°Ô∏è', color: '#339af0', type: 'shield', duration: 200, name: 'Firewall' },
            { emoji: '2X', color: '#51cf66', type: 'double', duration: 400, name: 'Double Points' },
            { emoji: 'üíä', color: '#ff6b6b', type: 'antivirus', duration: 1, name: 'Antivirus' }
        ];
        
        // Initialize game
        function initGame() {
            // Initialize worm
            worm = [
                { x: 10, y: 10 },
                { x: 9, y: 10 },
                { x: 8, y: 10 }
            ];
            
            // Reset game state
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            health = 3;
            gameSpeed = 10;
            frameCount = 0;
            food = [];
            obstacles = [];
            powerUps = [];
            
            // Reset power-ups
            speedBoost = 0;
            firewall = 0;
            doublePoints = 0;
            antivirus = 0;
            
            // Create initial food and obstacles
            for (let i = 0; i < 5; i++) {
                createFood();
            }
            
            for (let i = 0; i < 3; i++) {
                createObstacle();
            }
            
            // Update UI
            updateUI();
            
            // Show start message
            document.getElementById('startMessage').style.display = 'block';
            document.getElementById('gameOverMessage').style.display = 'none';
        }
        
        // Create food at random position
        function createFood() {
            let newFood;
            let overlapping;
            
            do {
                overlapping = false;
                newFood = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount),
                    type: fileTypes[Math.floor(Math.random() * fileTypes.length)]
                };
                
                // Check if position is occupied by worm
                for (let segment of worm) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                // Check if position is occupied by existing food
                for (let f of food) {
                    if (f.x === newFood.x && f.y === newFood.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                // Check if position is occupied by obstacles
                for (let obs of obstacles) {
                    if (obs.x === newFood.x && obs.y === newFood.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                // Check if position is occupied by power-ups
                for (let p of powerUps) {
                    if (p.x === newFood.x && p.y === newFood.y) {
                        overlapping = true;
                        break;
                    }
                }
                
            } while (overlapping);
            
            food.push(newFood);
        }
        
        // Create obstacle at random position
        function createObstacle() {
            let newObstacle;
            let overlapping;
            
            do {
                overlapping = false;
                newObstacle = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount),
                    type: 'infected'
                };
                
                // Check if position is occupied by worm
                for (let segment of worm) {
                    if (segment.x === newObstacle.x && segment.y === newObstacle.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                // Check if position is occupied by food
                for (let f of food) {
                    if (f.x === newObstacle.x && f.y === newObstacle.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                // Check if position is occupied by existing obstacles
                for (let obs of obstacles) {
                    if (obs.x === newObstacle.x && obs.y === newObstacle.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                // Check if position is occupied by power-ups
                for (let p of powerUps) {
                    if (p.x === newObstacle.x && p.y === newObstacle.y) {
                        overlapping = true;
                        break;
                    }
                }
                
            } while (overlapping);
            
            obstacles.push(newObstacle);
        }
        
        // Create power-up at random position
        function createPowerUp() {
            // Random chance to create power-up
            if (Math.random() > 0.02) return;
            
            let newPowerUp;
            let overlapping;
            
            do {
                overlapping = false;
                newPowerUp = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount),
                    type: powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)],
                    createdAt: Date.now()
                };
                
                // Check if position is occupied
                for (let segment of worm) {
                    if (segment.x === newPowerUp.x && segment.y === newPowerUp.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                for (let f of food) {
                    if (f.x === newPowerUp.x && f.y === newPowerUp.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                for (let obs of obstacles) {
                    if (obs.x === newPowerUp.x && obs.y === newPowerUp.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                for (let p of powerUps) {
                    if (p.x === newPowerUp.x && p.y === newPowerUp.y) {
                        overlapping = true;
                        break;
                    }
                }
                
            } while (overlapping);
            
            powerUps.push(newPowerUp);
        }
        
        // Update power-up timers
        function updatePowerUps() {
            if (speedBoost > 0) speedBoost--;
            if (firewall > 0) firewall--;
            if (doublePoints > 0) doublePoints--;
            if (antivirus > 0) antivirus--;
            
            // Remove expired power-ups
            powerUps = powerUps.filter(powerUp => {
                return Date.now() - powerUp.createdAt < 10000; // 10 second lifetime
            });
            
            updatePowerUpUI();
        }
        
        // Collect power-up
        function collectPowerUp(powerUp) {
            const powerUpElement = powerUp.type;
            
            switch (powerUpElement.type) {
                case 'speed':
                    speedBoost = powerUpElement.duration;
                    gameSpeed = 6; // Faster movement
                    break;
                case 'shield':
                    firewall = powerUpElement.duration;
                    break;
                case 'double':
                    doublePoints = powerUpElement.duration;
                    break;
                case 'antivirus':
                    antivirus = powerUpElement.duration;
                    health = Math.min(3, health + 1); // Restore health
                    break;
            }
            
            // Remove collected power-up
            powerUps = powerUps.filter(p => p !== powerUp);
            
            updateUI();
        }
        
        // Draw game elements
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0a192f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#112240';
            ctx.lineWidth = 0.5;
            for (let x = 0; x < tileCount; x++) {
                for (let y = 0; y < tileCount; y++) {
                    ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);
                }
            }
            
            // Draw worm
            for (let i = 0; i < worm.length; i++) {
                const segment = worm[i];
                
                // Head
                if (i === 0) {
                    ctx.fillStyle = firewall > 0 ? '#339af0' : '#40c057'; // Blue if shielded
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                    
                    // Draw eyes
                    ctx.fillStyle = '#000';
                    const eyeSize = gridSize / 5;
                    
                    // Eye positions based on direction
                    let leftEyeX, leftEyeY, rightEyeX, rightEyeY;
                    
                    if (direction.x === 1) { // Right
                        leftEyeX = segment.x * gridSize + gridSize - eyeSize * 2;
                        leftEyeY = segment.y * gridSize + eyeSize * 2;
                        rightEyeX = segment.x * gridSize + gridSize - eyeSize * 2;
                        rightEyeY = segment.y * gridSize + gridSize - eyeSize * 3;
                    } else if (direction.x === -1) { // Left
                        leftEyeX = segment.x * gridSize + eyeSize;
                        leftEyeY = segment.y * gridSize + eyeSize * 2;
                        rightEyeX = segment.x * gridSize + eyeSize;
                        rightEyeY = segment.y * gridSize + gridSize - eyeSize * 3;
                    } else if (direction.y === 1) { // Down
                        leftEyeX = segment.x * gridSize + eyeSize * 2;
                        leftEyeY = segment.y * gridSize + gridSize - eyeSize * 2;
                        rightEyeX = segment.x * gridSize + gridSize - eyeSize * 3;
                        rightEyeY = segment.y * gridSize + gridSize - eyeSize * 2;
                    } else { // Up
                        leftEyeX = segment.x * gridSize + eyeSize * 2;
                        leftEyeY = segment.y * gridSize + eyeSize;
                        rightEyeX = segment.x * gridSize + gridSize - eyeSize * 3;
                        rightEyeY = segment.y * gridSize + eyeSize;
                    }
                    
                    ctx.fillRect(leftEyeX, leftEyeY, eyeSize, eyeSize);
                    ctx.fillRect(rightEyeX, rightEyeY, eyeSize, eyeSize);
                }
                // Body
                else {
                    const colorValue = Math.floor(150 + (i / worm.length) * 105);
                    ctx.fillStyle = `rgb(64, ${colorValue}, 57)`;
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                    
                    // Body pattern
                    ctx.fillStyle = `rgb(44, ${colorValue - 40}, 37)`;
                    ctx.fillRect(segment.x * gridSize + 2, segment.y * gridSize + 2, gridSize - 4, gridSize - 4);
                }
                
                // Border
                ctx.strokeStyle = '#1a3c2a';
                ctx.lineWidth = 1;
                ctx.strokeRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
            }
            
            // Draw food
            for (let f of food) {
                ctx.fillStyle = f.type.color;
                ctx.beginPath();
                ctx.arc(
                    f.x * gridSize + gridSize / 2,
                    f.y * gridSize + gridSize / 2,
                    gridSize / 2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Draw file emoji
                ctx.font = `${gridSize * 0.7}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(
                    f.type.emoji,
                    f.x * gridSize + gridSize / 2,
                    f.y * gridSize + gridSize / 2
                );
            }
            
            // Draw obstacles (infected PCs)
            for (let obs of obstacles) {
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(obs.x * gridSize, obs.y * gridSize, gridSize, gridSize);
                
                // Draw warning symbol
                ctx.font = `${gridSize * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(
                    'üñ•Ô∏è',
                    obs.x * gridSize + gridSize / 2,
                    obs.y * gridSize + gridSize / 2
                );
                
                // Pulsing effect
                const pulse = Math.sin(Date.now() / 200) * 2;
                ctx.strokeStyle = '#ff8787';
                ctx.lineWidth = 2 + pulse;
                ctx.strokeRect(
                    obs.x * gridSize + 2,
                    obs.y * gridSize + 2,
                    gridSize - 4,
                    gridSize - 4
                );
            }
            
            // Draw power-ups
            for (let p of powerUps) {
                const age = Date.now() - p.createdAt;
                const blink = age > 8000 ? Math.floor(Date.now() / 200) % 2 : 0;
                
                if (blink) continue; // Blink when about to expire
                
                ctx.fillStyle = p.type.color;
                ctx.beginPath();
                ctx.roundRect(
                    p.x * gridSize + 2,
                    p.y * gridSize + 2,
                    gridSize - 4,
                    gridSize - 4,
                    6
                );
                ctx.fill();
                
                // Draw power-up emoji
                ctx.font = `${gridSize * 0.7}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(
                    p.type.emoji,
                    p.x * gridSize + gridSize / 2,
                    p.y * gridSize + gridSize / 2
                );
                
                // Rotating effect
                ctx.save();
                ctx.translate(
                    p.x * gridSize + gridSize / 2,
                    p.y * gridSize + gridSize / 2
                );
                ctx.rotate(age / 1000);
                ctx.strokeStyle = p.type.color;
                ctx.lineWidth = 2;
                ctx.strokeRect(-gridSize/4, -gridSize/4, gridSize/2, gridSize/2);
                ctx.restore();
            }
        }
        
        // Update game state
        function update() {
            if (!gameRunning || gamePaused || gameOver) return;
            
            frameCount++;
            
            // Update direction
            direction = { ...nextDirection };
            
            // Calculate movement speed
            const speed = speedBoost > 0 ? 6 : 10;
            
            if (frameCount % speed !== 0) return;
            
            // Move worm
            const head = { ...worm[0] };
            head.x += direction.x;
            head.y += direction.y;
            
            // Wrap around edges
            if (head.x < 0) head.x = tileCount - 1;
            if (head.x >= tileCount) head.x = 0;
            if (head.y < 0) head.y = tileCount - 1;
            if (head.y >= tileCount) head.y = 0;
            
            // Check collision with self
            for (let segment of worm) {
                if (segment.x === head.x && segment.y === head.y) {
                    if (firewall > 0) {
                        // Shield protects from self-collision
                        break;
                    } else {
                        gameOver = true;
                        endGame();
                        return;
                    }
                }
            }
            
            // Add new head
            worm.unshift(head);
            
            // Check collision with food
            let ateFood = false;
            for (let i = 0; i < food.length; i++) {
                if (food[i].x === head.x && food[i].y === head.y) {
                    // Calculate points
                    let points = food[i].type.value;
                    if (doublePoints > 0) points *= 2;
                    score += points;
                    
                    // Remove food
                    food.splice(i, 1);
                    ateFood = true;
                    
                    // Create new food
                    createFood();
                    
                    // Chance to create power-up
                    createPowerUp();
                    
                    // Chance to create obstacle every 5 foods
                    if (score % 50 === 0) {
                        createObstacle();
                    }
                    
                    break;
                }
            }
            
            // Check collision with obstacles
            for (let i = 0; i < obstacles.length; i++) {
                if (obstacles[i].x === head.x && obstacles[i].y === head.y) {
                    if (firewall > 0) {
                        // Shield protects from obstacle
                        obstacles.splice(i, 1);
                        createObstacle();
                    } else {
                        health--;
                        obstacles.splice(i, 1);
                        createObstacle();
                        
                        if (health <= 0) {
                            gameOver = true;
                            endGame();
                            return;
                        }
                    }
                    break;
                }
            }
            
            // Check collision with power-ups
            for (let i = 0; i < powerUps.length; i++) {
                if (powerUps[i].x === head.x && powerUps[i].y === head.y) {
                    collectPowerUp(powerUps[i]);
                    break;
                }
            }
            
            // Remove tail if no food was eaten
            if (!ateFood) {
                worm.pop();
            }
            
            // Update power-ups
            updatePowerUps();
            
            // Update UI
            updateUI();
            
            // Reset game speed if speed boost expired
            if (speedBoost === 0 && gameSpeed === 6) {
                gameSpeed = 10;
            }
        }
        
        // Update UI elements
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('length').textContent = worm.length;
            document.getElementById('health').textContent = health;
        }
        
        // Update power-up UI
        function updatePowerUpUI() {
            const speedElement = document.getElementById('speedPower');
            const shieldElement = document.getElementById('shieldPower');
            const doubleElement = document.getElementById('doublePower');
            const antivirusElement = document.getElementById('antivirusPower');
            
            speedElement.classList.toggle('active', speedBoost > 0);
            shieldElement.classList.toggle('active', firewall > 0);
            doubleElement.classList.toggle('active', doublePoints > 0);
            antivirusElement.classList.toggle('active', antivirus > 0);
            
            document.getElementById('speedTimer').textContent = 
                speedBoost > 0 ? Math.ceil(speedBoost / 60) + 's' : '0s';
            document.getElementById('shieldTimer').textContent = 
                firewall > 0 ? Math.ceil(firewall / 60) + 's' : '0s';
            document.getElementById('doubleTimer').textContent = 
                doublePoints > 0 ? Math.ceil(doublePoints / 60) + 's' : '0s';
            document.getElementById('antivirusTimer').textContent = 
                antivirus > 0 ? 'Active' : '0s';
        }
        
        // Handle keyboard input
        function handleKeyDown(e) {
            if (!gameRunning || gamePaused) return;
            
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction.y === 0) {
                        nextDirection = { x: 0, y: -1 };
                    }
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction.y === 0) {
                        nextDirection = { x: 0, y: 1 };
                    }
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction.x === 0) {
                        nextDirection = { x: -1, y: 0 };
                    }
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction.x === 0) {
                        nextDirection = { x: 1, y: 0 };
                    }
                    break;
                case ' ':
                    pauseGame();
                    break;
            }
        }
        
        // Start the game
        function startGame() {
            initGame();
            gameRunning = true;
            gameOver = false;
            document.getElementById('startMessage').style.display = 'none';
            document.getElementById('gameOverMessage').style.display = 'none';
        }
        
        // Pause the game
        function pauseGame() {
            if (gameOver) return;
            
            gamePaused = !gamePaused;
            const button = document.querySelector('button[onclick="pauseGame()"]');
            button.textContent = gamePaused ? '‚ñ∂Ô∏è RESUME' : '‚è∏Ô∏è PAUSE';
        }
        
        // Restart the game
        function restartGame() {
            initGame();
            gameRunning = true;
            gameOver = false;
            gamePaused = false;
            document.getElementById('gameOverMessage').style.display = 'none';
            document.getElementById('startMessage').style.display = 'none';
            
            const button = document.querySelector('button[onclick="pauseGame()"]');
            button.textContent = '‚è∏Ô∏è PAUSE';
        }
        
        // End the game
        function endGame() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = `Score: ${score}`;
            document.getElementById('gameOverMessage').style.display = 'block';
        }
        
        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize and start the game
        document.addEventListener('keydown', handleKeyDown);
        initGame();
        gameLoop();
        
        // Add roundRect polyfill for older browsers
        if (!ctx.roundRect) {
            ctx.roundRect = function(x, y, width, height, radius) {
                if (width < 2 * radius) radius = width / 2;
                if (height < 2 * radius) radius = height / 2;
                this.beginPath();
                this.moveTo(x + radius, y);
                this.arcTo(x + width, y, x + width, y + height, radius);
                this.arcTo(x + width, y + height, x, y + height, radius);
                this.arcTo(x, y + height, x, y, radius);
                this.arcTo(x, y, x + width, y, radius);
                this.closePath();
                return this;
            }
        }
    </script>
</body>
</html>
