<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Worm - School Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f1f5f9;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            max-width: 500px;
            width: 100%;
            text-align: center;
        }
        
        .header {
            margin-bottom: 20px;
        }
        
        h1 {
            color: #38bdf8;
            font-size: 2.2rem;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            color: #94a3b8;
            font-size: 1rem;
            margin-bottom: 15px;
        }
        
        .game-board {
            position: relative;
            background-color: #1e293b;
            border: 3px solid #334155;
            border-radius: 8px;
            margin: 0 auto 20px;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        }
        
        #gameCanvas {
            display: block;
            background-color: #0f172a;
        }
        
        .game-info {
            background-color: #1e293b;
            border: 2px solid #334155;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .stat-box {
            text-align: center;
            min-width: 100px;
        }
        
        .stat-label {
            color: #94a3b8;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }
        
        .stat-value {
            color: #f1f5f9;
            font-size: 1.8rem;
            font-weight: bold;
        }
        
        .instructions {
            background-color: #1e293b;
            border: 2px solid #334155;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .instructions h3 {
            color: #38bdf8;
            margin-bottom: 12px;
            font-size: 1.1rem;
        }
        
        .instructions-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            text-align: left;
        }
        
        .instruction-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        
        .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }
        
        button {
            background-color: #3b82f6;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        button:hover {
            background-color: #2563eb;
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(30, 41, 59, 0.95);
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            border: 3px solid #3b82f6;
            display: none;
            z-index: 10;
            width: 80%;
            max-width: 300px;
        }
        
        .game-message h2 {
            color: #38bdf8;
            margin-bottom: 15px;
            font-size: 1.8rem;
        }
        
        .game-message p {
            margin-bottom: 20px;
            font-size: 1rem;
            line-height: 1.5;
        }
        
        .firewall-warning {
            color: #f87171;
            font-weight: bold;
            margin-top: 10px;
            font-size: 0.9rem;
        }
        
        .firewalls-info {
            background-color: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 6px;
            padding: 10px;
            margin-top: 15px;
            font-size: 0.9rem;
        }
        
        @media (max-width: 400px) {
            .game-info {
                flex-direction: column;
                align-items: center;
            }
            
            .instructions-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üñ•Ô∏è Cyber Worm Challenge</h1>
            <p class="subtitle">Eat files, avoid firewalls, don't crash!</p>
        </div>
        
        <div class="game-board">
            <canvas id="gameCanvas" width="400" height="400"></canvas>
            <div id="startMessage" class="game-message">
                <h2>Ready to Hack?</h2>
                <p>Use <strong>Arrow Keys</strong> or <strong>WASD</strong> to move</p>
                <p>Eat files to grow longer</p>
                <p>Avoid red firewalls!</p>
                <button onclick="startGame()">START GAME</button>
            </div>
            <div id="gameOverMessage" class="game-message">
                <h2>Game Over!</h2>
                <p id="finalScore">Score: 0</p>
                <p id="finalLength">Length: 0</p>
                <button onclick="restartGame()">PLAY AGAIN</button>
            </div>
        </div>
        
        <div class="game-info">
            <div class="stat-box">
                <div class="stat-label">üìÅ Files Eaten</div>
                <div id="score" class="stat-value">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">üêõ Worm Length</div>
                <div id="length" class="stat-value">3</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">üî• Firewalls</div>
                <div id="firewallCount" class="stat-value">0</div>
            </div>
        </div>
        
        <div class="instructions">
            <h3>üéÆ Game Elements</h3>
            <div class="instructions-grid">
                <div class="instruction-item">
                    <div class="color-dot" style="background-color: #10b981;"></div>
                    <span>Worm Head</span>
                </div>
                <div class="instruction-item">
                    <div class="color-dot" style="background-color: #059669;"></div>
                    <span>Worm Body</span>
                </div>
                <div class="instruction-item">
                    <div class="color-dot" style="background-color: #3b82f6;"></div>
                    <span>Files</span>
                </div>
                <div class="instruction-item">
                    <div class="color-dot" style="background-color: #ef4444;"></div>
                    <span>Firewall (Enemy)</span>
                </div>
            </div>
            
            <div class="firewalls-info">
                ‚ö†Ô∏è <strong>Warning:</strong> Firewalls move and will end your game!
                More firewalls appear as your worm grows longer.
            </div>
        </div>
        
        <div class="controls">
            <button onclick="pauseGame()">‚è∏Ô∏è PAUSE</button>
            <button onclick="restartGame()">üîÑ RESTART</button>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 20;
        const tileCount = canvas.width / gridSize;
        
        let worm = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let food = [];
        let firewalls = [];
        let gameSpeed = 10;
        let frameCount = 0;
        let score = 0;
        let gameRunning = false;
        let gamePaused = false;
        let gameOver = false;
        
        // Initialize game
        function initGame() {
            // Initialize worm in the center
            worm = [
                { x: 10, y: 10 },
                { x: 9, y: 10 },
                { x: 8, y: 10 }
            ];
            
            // Reset game state
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            gameSpeed = 10;
            frameCount = 0;
            food = [];
            firewalls = [];
            
            // Create initial food
            for (let i = 0; i < 3; i++) {
                createFood();
            }
            
            // Create initial firewalls
            createFirewall();
            createFirewall();
            
            // Update UI
            updateUI();
            
            // Show start message
            document.getElementById('startMessage').style.display = 'block';
            document.getElementById('gameOverMessage').style.display = 'none';
        }
        
        // Create food at random position
        function createFood() {
            let newFood;
            let overlapping;
            
            do {
                overlapping = false;
                newFood = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                
                // Check if position is occupied by worm
                for (let segment of worm) {
                    if (segment.x === newFood.x && segment.y === newFood.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                // Check if position is occupied by existing food
                for (let f of food) {
                    if (f.x === newFood.x && f.y === newFood.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                // Check if position is occupied by firewalls
                for (let fw of firewalls) {
                    if (fw.x === newFood.x && fw.y === newFood.y) {
                        overlapping = true;
                        break;
                    }
                }
                
            } while (overlapping);
            
            food.push(newFood);
        }
        
        // Create firewall at random position
        function createFirewall() {
            let newFirewall;
            let overlapping;
            
            do {
                overlapping = false;
                newFirewall = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount),
                    direction: Math.random() > 0.5 ? 'horizontal' : 'vertical',
                    moveCounter: 0,
                    moveEvery: Math.floor(Math.random() * 3) + 2 // Move every 2-4 frames
                };
                
                // Don't spawn too close to worm head
                const head = worm[0];
                if (Math.abs(newFirewall.x - head.x) < 3 && Math.abs(newFirewall.y - head.y) < 3) {
                    overlapping = true;
                    continue;
                }
                
                // Check if position is occupied by worm
                for (let segment of worm) {
                    if (segment.x === newFirewall.x && segment.y === newFirewall.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                // Check if position is occupied by food
                for (let f of food) {
                    if (f.x === newFirewall.x && f.y === newFirewall.y) {
                        overlapping = true;
                        break;
                    }
                }
                
                // Check if position is occupied by existing firewalls
                for (let fw of firewalls) {
                    if (fw.x === newFirewall.x && fw.y === newFirewall.y) {
                        overlapping = true;
                        break;
                    }
                }
                
            } while (overlapping);
            
            firewalls.push(newFirewall);
        }
        
        // Move firewalls
        function moveFirewalls() {
            for (let firewall of firewalls) {
                firewall.moveCounter++;
                
                if (firewall.moveCounter >= firewall.moveEvery) {
                    firewall.moveCounter = 0;
                    
                    // Try to move in current direction
                    let newX = firewall.x;
                    let newY = firewall.y;
                    
                    if (firewall.direction === 'horizontal') {
                        newX += Math.random() > 0.5 ? 1 : -1;
                    } else {
                        newY += Math.random() > 0.5 ? 1 : -1;
                    }
                    
                    // Check boundaries
                    if (newX >= 0 && newX < tileCount && newY >= 0 && newY < tileCount) {
                        // Check if new position is occupied
                        let canMove = true;
                        
                        for (let segment of worm) {
                            if (segment.x === newX && segment.y === newY) {
                                canMove = false;
                                break;
                            }
                        }
                        
                        for (let f of food) {
                            if (f.x === newX && f.y === newY) {
                                canMove = false;
                                break;
                            }
                        }
                        
                        for (let fw of firewalls) {
                            if (fw !== firewall && fw.x === newX && fw.y === newY) {
                                canMove = false;
                                break;
                            }
                        }
                        
                        if (canMove) {
                            firewall.x = newX;
                            firewall.y = newY;
                        } else {
                            // Change direction if can't move
                            firewall.direction = firewall.direction === 'horizontal' ? 'vertical' : 'horizontal';
                        }
                    } else {
                        // Change direction if at boundary
                        firewall.direction = firewall.direction === 'horizontal' ? 'vertical' : 'horizontal';
                    }
                }
            }
        }
        
        // Draw game elements
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid (subtle)
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 0.5;
            for (let x = 0; x < tileCount; x++) {
                for (let y = 0; y < tileCount; y++) {
                    ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);
                }
            }
            
            // Draw worm
            for (let i = 0; i < worm.length; i++) {
                const segment = worm[i];
                
                // Head (brighter green)
                if (i === 0) {
                    ctx.fillStyle = '#10b981';
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                    
                    // Draw eyes
                    ctx.fillStyle = '#000';
                    const eyeSize = gridSize / 5;
                    
                    let leftEyeX, leftEyeY, rightEyeX, rightEyeY;
                    
                    if (direction.x === 1) { // Right
                        leftEyeX = segment.x * gridSize + gridSize - eyeSize * 2;
                        leftEyeY = segment.y * gridSize + eyeSize * 2;
                        rightEyeX = segment.x * gridSize + gridSize - eyeSize * 2;
                        rightEyeY = segment.y * gridSize + gridSize - eyeSize * 3;
                    } else if (direction.x === -1) { // Left
                        leftEyeX = segment.x * gridSize + eyeSize;
                        leftEyeY = segment.y * gridSize + eyeSize * 2;
                        rightEyeX = segment.x * gridSize + eyeSize;
                        rightEyeY = segment.y * gridSize + gridSize - eyeSize * 3;
                    } else if (direction.y === 1) { // Down
                        leftEyeX = segment.x * gridSize + eyeSize * 2;
                        leftEyeY = segment.y * gridSize + gridSize - eyeSize * 2;
                        rightEyeX = segment.x * gridSize + gridSize - eyeSize * 3;
                        rightEyeY = segment.y * gridSize + gridSize - eyeSize * 2;
                    } else { // Up
                        leftEyeX = segment.x * gridSize + eyeSize * 2;
                        leftEyeY = segment.y * gridSize + eyeSize;
                        rightEyeX = segment.x * gridSize + gridSize - eyeSize * 3;
                        rightEyeY = segment.y * gridSize + eyeSize;
                    }
                    
                    ctx.fillRect(leftEyeX, leftEyeY, eyeSize, eyeSize);
                    ctx.fillRect(rightEyeX, rightEyeY, eyeSize, eyeSize);
                }
                // Body (darker green)
                else {
                    ctx.fillStyle = '#059669';
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize, gridSize);
                    
                    // Body pattern
                    ctx.fillStyle = '#047857';
                    ctx.fillRect(segment.x * gridSize + 2, segment.y * gridSize + 2, gridSize - 4, gridSize - 4);
                }
            }
            
            // Draw food (blue files)
            for (let f of food) {
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath();
                ctx.arc(
                    f.x * gridSize + gridSize / 2,
                    f.y * gridSize + gridSize / 2,
                    gridSize / 2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Draw file icon
                ctx.font = `${gridSize * 0.7}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(
                    'üìÅ',
                    f.x * gridSize + gridSize / 2,
                    f.y * gridSize + gridSize / 2
                );
                
                // Pulsing effect
                const pulse = Math.sin(Date.now() / 500) * 1;
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 1 + pulse;
                ctx.strokeRect(
                    f.x * gridSize + 2,
                    f.y * gridSize + 2,
                    gridSize - 4,
                    gridSize - 4
                );
            }
            
            // Draw firewalls (red with clear warning symbol)
            for (let fw of firewalls) {
                // Main red square
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(fw.x * gridSize, fw.y * gridSize, gridSize, gridSize);
                
                // Darker border
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = 2;
                ctx.strokeRect(fw.x * gridSize, fw.y * gridSize, gridSize, gridSize);
                
                // Warning symbol
                ctx.fillStyle = '#fff';
                ctx.font = `${gridSize * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    '‚ö†Ô∏è',
                    fw.x * gridSize + gridSize / 2,
                    fw.y * gridSize + gridSize / 2
                );
                
                // Pulsing red glow effect
                const pulse = Math.sin(Date.now() / 200) * 3;
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
                ctx.lineWidth = 2 + pulse;
                ctx.strokeRect(
                    fw.x * gridSize - pulse,
                    fw.y * gridSize - pulse,
                    gridSize + pulse * 2,
                    gridSize + pulse * 2
                );
            }
        }
        
        // Update game state
        function update() {
            if (!gameRunning || gamePaused || gameOver) return;
            
            frameCount++;
            
            // Update direction
            direction = { ...nextDirection };
            
            if (frameCount % gameSpeed !== 0) return;
            
            // Move worm
            const head = { ...worm[0] };
            head.x += direction.x;
            head.y += direction.y;
            
            // Check wall collision (game over at walls)
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver = true;
                endGame();
                return;
            }
            
            // Check collision with self
            for (let segment of worm) {
                if (segment.x === head.x && segment.y === head.y) {
                    gameOver = true;
                    endGame();
                    return;
                }
            }
            
            // Check collision with firewalls
            for (let firewall of firewalls) {
                if (firewall.x === head.x && firewall.y === head.y) {
                    gameOver = true;
                    endGame();
                    return;
                }
            }
            
            // Add new head
            worm.unshift(head);
            
            // Check collision with food
            let ateFood = false;
            for (let i = 0; i < food.length; i++) {
                if (food[i].x === head.x && food[i].y === head.y) {
                    score += 10;
                    food.splice(i, 1);
                    ateFood = true;
                    
                    // Create new food
                    createFood();
                    
                    // Add new firewall every 3 foods (makes game harder as you grow)
                    if (score % 30 === 0 && firewalls.length < 8) {
                        createFirewall();
                    }
                    
                    break;
                }
            }
            
            // Remove tail if no food was eaten
            if (!ateFood) {
                worm.pop();
            }
            
            // Move firewalls
            moveFirewalls();
            
            // Update UI
            updateUI();
        }
        
        // Update UI elements
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('length').textContent = worm.length;
            document.getElementById('firewallCount').textContent = firewalls.length;
        }
        
        // Handle keyboard input
        function handleKeyDown(e) {
            if (!gameRunning || gamePaused) return;
            
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (direction.y === 0) {
                        nextDirection = { x: 0, y: -1 };
                    }
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (direction.y === 0) {
                        nextDirection = { x: 0, y: 1 };
                    }
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (direction.x === 0) {
                        nextDirection = { x: -1, y: 0 };
                    }
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (direction.x === 0) {
                        nextDirection = { x: 1, y: 0 };
                    }
                    break;
                case ' ':
                    pauseGame();
                    break;
            }
        }
        
        // Start the game
        function startGame() {
            initGame();
            gameRunning = true;
            gameOver = false;
            document.getElementById('startMessage').style.display = 'none';
        }
        
        // Pause the game
        function pauseGame() {
            if (gameOver) return;
            
            gamePaused = !gamePaused;
            const button = document.querySelector('button[onclick="pauseGame()"]');
            button.textContent = gamePaused ? '‚ñ∂Ô∏è RESUME' : '‚è∏Ô∏è PAUSE';
        }
        
        // Restart the game
        function restartGame() {
            initGame();
            gameRunning = true;
            gameOver = false;
            gamePaused = false;
            document.getElementById('gameOverMessage').style.display = 'none';
            
            const button = document.querySelector('button[onclick="pauseGame()"]');
            button.textContent = '‚è∏Ô∏è PAUSE';
        }
        
        // End the game
        function endGame() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = `Score: ${score}`;
            document.getElementById('finalLength').textContent = `Length: ${worm.length}`;
            document.getElementById('gameOverMessage').style.display = 'block';
        }
        
        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize and start the game
        document.addEventListener('keydown', handleKeyDown);
        initGame();
        gameLoop();
    </script>
</body>
</html>
