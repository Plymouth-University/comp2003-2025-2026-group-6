<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tower Stack — Mini Game</title>
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent: linear-gradient(90deg,#ffb86b,#ff6b6b,#8b5cf6);
      --ui:#cbd5e1;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
    body{
      background: radial-gradient(1200px 600px at 10% 20%, rgba(139,92,246,0.10), transparent),
                  radial-gradient(900px 500px at 90% 80%, rgba(99,102,241,0.07), transparent),
                  var(--bg);
      color:var(--ui);
      display:flex;align-items:center;justify-content:center;padding:24px;
    }

    .screen{
      width:360px;max-width:calc(100vw - 40px);height:720px;max-height:calc(100vh - 40px);
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:18px;padding:18px;box-shadow:0 8px 30px rgba(2,6,23,0.7);position:relative;overflow:hidden;
      display:flex;flex-direction:column;
    }

    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
    h1{font-size:16px;margin:0}
    .score, .best{font-size:13px;opacity:0.9}

    .play-area{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:10px;flex:1;position:relative;overflow:hidden;display:flex;align-items:flex-end;justify-content:center;padding-bottom:30px;
    }

    /* Tower stack container */
    .tower{
      width:280px;height:100%;position:relative;display:flex;flex-direction:column-reverse;align-items:center;pointer-events:none;
      transition: transform 0.35s cubic-bezier(.2,.8,.2,1);
      will-change: transform;
    }

    .block{
      height:36px;border-radius:6px;position:absolute;left:50%;transform:translateX(-50%);will-change:transform,width,background;
      display:flex;align-items:center;justify-content:center;color:rgba(0,0,0,0.6);font-weight:600;user-select:none;box-shadow:0 6px 18px rgba(2,6,23,0.45), inset 0 -6px 12px rgba(255,255,255,0.02);
    }

    .moving{pointer-events:auto;cursor:pointer}

    footer{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-top:12px}
    .controls{display:flex;gap:8px}
    button{background:linear-gradient(180deg,#1f2a44,#111827);border:none;color:var(--ui);padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06)}

    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .msg{background:rgba(2,6,23,0.6);backdrop-filter:blur(6px);padding:14px 18px;border-radius:12px;color:var(--ui);text-align:center;pointer-events:auto}
    .msg small{display:block;opacity:0.8;margin-top:6px}

    .hint{position:absolute;top:12px;left:50%;transform:translateX(-50%);font-size:12px;opacity:0.8}

    @media (max-width:420px){ .screen{height:88vh} .tower{width:92%} }
  </style>
</head>
<body>
  <div class="screen" role="application" aria-label="Tower Stack game">
    <header>
      <h1>Tower Stack</h1>
      <div>
        <div class="score">Score: <span id="score">0</span></div>
        <div class="best">Best: <span id="best">0</span></div>
      </div>
    </header>

    <div class="play-area" id="playArea">
      <div class="tower" id="tower"></div>
      <div class="hint">Tap / Click / Space to drop — stack as high as you can</div>
    </div>

    <footer>
      <div class="controls">
        <button id="restart">Restart</button>
        <button id="autoplay" class="secondary">Autoplay</button>
      </div>
      <div style="opacity:0.9;font-size:13px">Width shrinks on partial overlap — miss and it's over</div>
    </footer>

    <div class="overlay" id="overlay" style="display:none">
      <div class="msg" id="message">
        <div id="msgTitle">Game Over</div>
        <small id="msgSub">Score: 0 — Tap to play again</small>
      </div>
    </div>
  </div>

  <script>
  /* Tower Stack — Single-file JS
     Mechanics:
      - Blocks move horizontally across the tower area
      - Player drops the moving block; overlap with previous block determines new width
      - Perfect alignments (within tolerance) grant combo bonuses
      - Speed increases as stack grows
      - Stores best score in localStorage
  */

  (function(){
    const tower = document.getElementById('tower');
    const playArea = document.getElementById('playArea');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const msgTitle = document.getElementById('msgTitle');
    const msgSub = document.getElementById('msgSub');
    const restartBtn = document.getElementById('restart');
    const autoplayBtn = document.getElementById('autoplay');

    let state = null;

    function randomColor(seed){
      // easy pleasing gradient-ish colors based on seed
      const hues = [18,28,210,260,330,40,190];
      const h = hues[seed % hues.length];
      return `linear-gradient(90deg, hsl(${h} 80% 70%), hsl(${(h+30)%360} 76% 58%))`;
    }

    function createBlock(width, bottomIndex, color, isMoving=false){
      const el = document.createElement('div');
      el.className = 'block' + (isMoving? ' moving':'');
      el.style.width = width + 'px';
      // vertical position: bottomIndex * blockHeight
      const blockHeight = 36;
      const y = bottomIndex * (blockHeight + 8) + 10; // add small padding
      el.style.bottom = y + 'px';
      el.style.background = color;
      el.dataset.width = width;
      el.dataset.bottomIndex = bottomIndex;
      tower.appendChild(el);
      return el;
    }

    function clearTower(){
      tower.innerHTML = '';
    }

    function resetState(){
      state = {
        stack: [], // objects {el,left,width,bottomIndex}
        baseWidth: 260,
        baseLeft: 10,
        blockHeight:36,
        gap:8,
        speed:2.5, // px per frame initial
        score:0,
        best: parseInt(localStorage.getItem('tower_best') || '0',10),
        moving: null,
        running: true,
        autoplay: false,
        combo:0,
      };
      bestEl.textContent = state.best;
      scoreEl.textContent = '0';
    }

    function spawnBase(){
      const color = randomColor(0);
      const base = createBlock(state.baseWidth, 0, color, false);
      // center it
      base.style.left = '50%';
      base.style.transform = 'translateX(-50%)';
      // store
      state.stack.push({el:base,left:(playArea.clientWidth - state.baseWidth)/2,width:state.baseWidth,bottomIndex:0});
    }

    function spawnMoving(){
      const top = state.stack[state.stack.length - 1];
      const bottomIndex = state.stack.length; // next index
      const width = top.width; // start with same width
      const color = randomColor(bottomIndex);
      const el = createBlock(width, bottomIndex, color, true);

      // movement parameters
      const startLeft = -width - 20; // start off left
      const endLeft = playArea.clientWidth + 20; // off right
      el.style.left = startLeft + 'px';
      el.style.transform = 'translateX(0)';

      const direction = 1; // move right initially
      state.moving = {el,left:startLeft,width,bottomIndex,dir:direction,endLeft};
    }

    function updateMoving(){
      if(!state.moving) return;
      // adapt speed based on stack height
      const heightFactor = 1 + state.stack.length * 0.08; // faster as taller
      const speed = state.speed * heightFactor;
      let m = state.moving;
      // update left
      m.left += speed * m.dir;
      // bounce at edges
      const leftLimit = -m.width - 30;
      const rightLimit = playArea.clientWidth + 30;
      if(m.left > rightLimit){ m.dir = -1; m.left = rightLimit; }
      if(m.left < leftLimit){ m.dir = 1; m.left = leftLimit; }
      m.el.style.left = m.left + 'px';
    }

    function dropMoving(){
      if(!state.moving || !state.running) return;
      const m = state.moving;
      const top = state.stack[state.stack.length - 1];
      // compute overlap between m and top
      const mLeft = m.left;
      const mRight = mLeft + m.width;
      const tLeft = top.left;
      const tRight = top.left + top.width;

      const overlapLeft = Math.max(mLeft, tLeft);
      const overlapRight = Math.min(mRight, tRight);
      const overlap = Math.max(0, overlapRight - overlapLeft);

      if(overlap <= 0){
        // miss
        endGame(false);
        return;
      }

      // perfect? allow small tolerance
      const tolerance = Math.min(12, Math.floor(top.width * 0.04));
      const isPerfect = Math.abs(overlap - top.width) <= tolerance && Math.abs(mLeft - tLeft) <= tolerance;

      // update width and left of new top
      const newWidth = overlap;
      const newLeft = overlapLeft;

      // create a settled block element to replace moving
      m.el.classList.remove('moving');
      m.el.style.left = (newLeft) + 'px';
      m.el.style.transform = 'translateX(0)';
      m.el.style.width = newWidth + 'px';
      m.el.dataset.width = newWidth;

      // animate the cut-off piece
      const cutLeft = mLeft < tLeft ? mLeft : overlapRight;
      const cutWidth = m.width - overlap;
      if(cutWidth > 4){
        const piece = document.createElement('div');
        piece.className = 'block';
        piece.style.width = cutWidth + 'px';
        piece.style.bottom = m.el.style.bottom;
        piece.style.left = (mLeft < tLeft ? m.left : overlapRight) + 'px';
        piece.style.transform = 'translateX(0)';
        piece.style.borderRadius = '6px';
        piece.style.opacity = '0.95';
        piece.style.background = m.el.style.background;
        tower.appendChild(piece);
        // fall animation
        piece.animate([
          { transform: `translateY(0)`, opacity:1 },
          { transform: `translateY(220px)`, opacity:0 }
        ],{ duration: 700, easing:'cubic-bezier(.2,.8,.2,1)' });
        setTimeout(()=> piece.remove(),740);
      }

      // commit new top
      state.stack.push({el:m.el,left:newLeft,width:newWidth,bottomIndex:m.bottomIndex});
      state.moving = null;

      // scoring
      state.score += isPerfect ? 2 : 1;
      scoreEl.textContent = state.score;
      if(state.score > state.best){ state.best = state.score; localStorage.setItem('tower_best', String(state.best)); bestEl.textContent = state.best; }

      // combo handling
      if(isPerfect){ state.combo++; if(state.combo > 2){ state.score += 1; scoreEl.textContent = state.score; } }
      else state.combo = 0;

      // if the new width is too small, game over
      if(newWidth < 34){ endGame(true); return; }

      // scroll tower visually if needed
      adjustTowerView();

      // spawn next moving block after a short delay
      setTimeout(()=>{ if(state.running){ spawnMoving(); } }, 160);
    }

    function adjustTowerView(){
      // keep the top visible by smoothly shifting tower's translateY
      const topIndex = state.stack.length - 1;
      const blockHeight = state.blockHeight + state.gap;
      const visibleBlocks = Math.floor((playArea.clientHeight - 40)/blockHeight);

      if(topIndex > visibleBlocks - 2){
        const shift = (topIndex - (visibleBlocks - 2)) * blockHeight;
        tower.style.transform = `translateY(${shift}px)`;
      }
    }

    function endGame(nearLose=false){
      state.running = false;
      overlay.style.display = 'flex';
      msgTitle.textContent = 'Game Over';
      msgSub.textContent = `Score: ${state.score} — Tap to play again`;
      overlay.querySelector('.msg').focus?.();
    }

    function startGame(){
      clearTower();
      resetState();
      spawnBase();
      spawnMoving();
      state.running = true;
      overlay.style.display = 'none';
    }

    // animation loop
    function loop(){
      if(state && state.running && state.moving){
        updateMoving();
      }
      requestAnimationFrame(loop);
    }

    // input handlers
    function handleDrop(){
      if(!state.running){ startGame(); return; }
      dropMoving();
    }

    // toggle autoplay (simple)
    function toggleAutoplay(){ state.autoplay = !state.autoplay; autoplayBtn.textContent = state.autoplay? 'Autoplay: ON' : 'Autoplay'; }

    // small AI for autoplay
    function autoplayTick(){
      if(!state || !state.running || !state.moving || !state.autoplay) return;
      const m = state.moving; const top = state.stack[state.stack.length-1];
      const center = top.left + top.width/2;
      const mCenter = m.left + m.width/2;
      // drop when centers align within some threshold influenced by speed
      const threshold = Math.max(6, 24 - state.stack.length);
      if(Math.abs(center - mCenter) < threshold){ dropMoving(); }
    }

    // event wiring
    window.addEventListener('keydown', (e)=>{ if(e.code === 'Space'){ e.preventDefault(); handleDrop(); } });
    playArea.addEventListener('click', ()=> handleDrop());
    restartBtn.addEventListener('click', ()=> startGame());
    autoplayBtn.addEventListener('click', ()=> toggleAutoplay());
    overlay.addEventListener('click', ()=> startGame());

    // responsiveness
    window.addEventListener('resize', ()=>{
      // recompute base left
      if(state && state.stack.length){
        state.stack[0].left = (playArea.clientWidth - state.stack[0].width)/2;
        // reposition all settled blocks horizontally relative to playArea center
        state.stack.forEach(item=>{
          item.el.style.left = item.left + 'px';
        });
      }
    });

    // main loops
    requestAnimationFrame(loop);
    setInterval(autoplayTick,100);

    // initialize
    resetState();
    spawnBase();
    spawnMoving();

  })();
  </script>
</body>
</html>
